//-----------------------------------------------------------------------------------------
// conjure_enum (header only)
// Copyright (C) 2024 Fix8 Market Technologies Pty Ltd
//   by David L. Dight
// see https://github.com/fix8mt/conjure_enum
//
//		Based on magic_enum <https://github.com/Neargye/magic_enum>
//		Licensed under the MIT License <http://opensource.org/licenses/MIT>.
//		SPDX-License-Identifier: MIT
//		Copyright (c) 2019 - 2024 Daniil Goncharov <neargye@gmail.com>.
//
// Lightweight header-only C++20 enum reflection
//
// Distributed under the Boost Software License, Version 1.0 August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//----------------------------------------------------------------------------------------
#include <iostream>
#include <iomanip>

#include <fix8/conjure_enum.hpp>

//-----------------------------------------------------------------------------------------
using namespace FIX8;

enum class component : int { scheme, authority, userinfo, user, password, host, port, path=12, test=path, query, fragment };
enum component1 : int { scheme, authority, userinfo, user, password, host, port, path=12, query, fragment };

int main()
{
	/*
	std::cout << get_name(epeek<component, component::user>()) << '\n';
	*/
	if (conjure_enum::is_valid<component, component::password>())
		std::cout << "valid\n";
	else
		std::cout << "not valid\n";
	if (conjure_enum::is_valid<component, static_cast<component>(16)>())
		std::cout << "valid\n";
	else
		std::cout << "not valid\n";

	for(const auto ev : conjure_enum::enum_values<component>)
		std::cout << static_cast<int>(ev) << '\n';
	for(const auto [a, b] : conjure_enum::enum_entries<component>)
		std::cout << static_cast<int>(a) << ' ' << b << '\n';
	for(const auto ev : conjure_enum::enum_values<component1>)
		std::cout << static_cast<int>(ev) << '\n';
	for(const auto ev : conjure_enum::enum_names<component>)
		std::cout << ev << '\n';
	std::cout << conjure_enum::enum_names<component>[5] << '\n';

	std::cout << "1: " << std::string_view(conjure_enum::enum_name_v<component, component::fragment>) << '\n';
	std::cout << "2: " << conjure_enum::enum_name<component, component::fragment>().get() << '\n';
	std::cout << "3: " << conjure_enum::enum_to_string(component::path) << '\n';
	std::cout << "4: " << conjure_enum::enum_to_string(component::test) << '\n';
	std::cout << "5: " << conjure_enum::enum_to_string(path) << '\n';
	std::cout << "6: " << static_cast<int>(conjure_enum::string_to_enum<component>("component::path").value()) << '\n';
	std::cout << "7: " << static_cast<int>(conjure_enum::string_to_enum<component1>("path").value()) << '\n';
	std::cout << "8: " << static_cast<int>(conjure_enum::string_to_enum<component>("wrong").value_or(component(100))) << '\n';
	std::cout << "9: " << conjure_enum::get_name<component1, scheme>() << '\n';
	std::cout << "10: " << conjure_enum::get_name<component, component::scheme>() << '\n';
	std::cout << "16: " << conjure_enum::get_type<component>() << '\n';
	std::cout << "16: " << conjure_enum::get_type<component1>() << '\n';

	//using enum component;
	//std::cout << std::boolalpha << is_scoped<component, scheme>() << '\n';
	std::cout << "11: " << std::boolalpha << conjure_enum::is_scoped<component>() << '\n';
	std::cout << "12: " << std::boolalpha << conjure_enum::is_scoped<component1>() << '\n';
	std::string_view res1 { conjure_enum::enum_name_v<component, component::userinfo> };
	std::cout << "13: " << res1 << '\n';
	std::cout << "14: " << conjure_enum::enum_name_v<component, component::userinfo> << '\n';
	std::cout << "15: " << conjure_enum::count<component>() << '\n';
	if (auto result {conjure_enum::int_to_enum<component>(100)}; result)
		std::cout << static_cast<int>(*result) << '\n';
	else
		std::cout << "invalid int to enum\n";
	if (auto result {conjure_enum::int_to_enum<component>(12)}; result)
		std::cout << static_cast<int>(*result) << '\n';
	else
		std::cout << "invalid int to enum\n";

	int total{};
	auto myfunc { conjure_enum::for_each<component>([](component val, int other, int& tot)
	{
		std::cout << static_cast<int>(val) << ' ' << other << '\n';
		tot += static_cast<int>(val);
	}, 10, std::ref(total)) };
	myfunc(component::fragment);
	std::cout << total << '\n';

	return 0;
}
