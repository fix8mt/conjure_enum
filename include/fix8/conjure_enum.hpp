//-----------------------------------------------------------------------------------------
// conjure_enum (header only)
// Copyright (C) 2024 Fix8 Market Technologies Pty Ltd
//   by David L. Dight
// see https://github.com/fix8mt/conjure_enum
//
//		Based on magic_enum <https://github.com/Neargye/magic_enum>
//		Licensed under the MIT License <http://opensource.org/licenses/MIT>.
//		SPDX-License-Identifier: MIT
//		Copyright (c) 2019 - 2024 Daniil Goncharov <neargye@gmail.com>.
//
// Lightweight header-only C++20 magic enum implementation
//
// Distributed under the Boost Software License, Version 1.0 August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//----------------------------------------------------------------------------------------
#ifndef FIX8_CONJURE_ENUM_HPP_
#define FIX8_CONJURE_ENUM_HPP_

//----------------------------------------------------------------------------------------
#include <source_location>
#include <algorithm>
#include <string_view>
#include <tuple>
#include <concepts>
#include <optional>
#include <ostream>
#include <cstddef>
#include <array>

//-----------------------------------------------------------------------------------------
namespace FIX8 {

//-----------------------------------------------------------------------------------------
#if not defined ENUM_MIN_VALUE
# define ENUM_MIN_VALUE 0
#endif
#if not defined ENUM_MAX_VALUE
# define ENUM_MAX_VALUE 127
#endif

//-----------------------------------------------------------------------------------------
template<std::size_t N>
class fixed_string
{
	std::array<char, N + 1> _buff{};
public:
	constexpr fixed_string(std::string_view sv) noexcept { std::copy(sv.cbegin(), sv.cend(), _buff.begin()); }
	constexpr fixed_string() = delete;
	constexpr std::string_view get() const noexcept { return { _buff.data(), N }; }
	constexpr operator std::string_view() const noexcept { return get(); }
	constexpr std::size_t size() const noexcept { return _buff.size(); }
	friend std::ostream& operator<<(std::ostream& os, const fixed_string& what) { return os << what.get(); }
};

class conjure_enum
{
	static constexpr int enum_min_value{ENUM_MIN_VALUE}, enum_max_value{ENUM_MAX_VALUE};

	template<typename T, T e>
	requires std::is_enum_v<T>
	static consteval const char *epeek() noexcept
	{
		return std::source_location::current().function_name();
	}

	template<typename T>
	requires std::is_enum_v<T>
	static consteval const char *tpeek() noexcept
	{
		return std::source_location::current().function_name();
	}

	template<typename T, std::size_t... I>
	static constexpr auto entries(std::index_sequence<I...>) noexcept
	{
		return std::array<std::tuple<T, std::string_view>, sizeof...(I)>{{{ enum_values<T>[I], enum_name_v<T, enum_values<T>[I]>}...}};
	}

	template<typename T, std::size_t... I>
	static constexpr auto names(std::index_sequence<I...>) noexcept
	{
		return std::array<std::string_view, sizeof...(I)>{{{ enum_name_v<T, enum_values<T>[I]>}...}};
	}

	template<typename T, std::size_t... I>
	static constexpr auto values(std::index_sequence<I...>) noexcept
	{
		constexpr std::array<bool, sizeof...(I)> valid { is_valid<T, static_cast<T>(enum_min_value + I)>()... };
		constexpr auto num_valid { std::count_if(valid.cbegin(), valid.cend(), [](bool val) noexcept { return val; }) };
		static_assert(num_valid > 0, "empty enums not supported");
		std::array<T, num_valid> vals{};
		for(std::size_t offset{}, nn{}; nn < num_valid; ++offset)
			if (valid[offset])
				vals[nn++] = static_cast<T>(enum_min_value + offset);
		return vals;
	}

public:
	conjure_enum() = delete;

	template<typename T, T e>
	requires std::is_enum_v<T>
	static constexpr std::string_view get_name() noexcept
	{
		/*
			static consteval const char* epeek() [with T = unscoped name; T e = <value>]
			static consteval const char* epeek() [with T = scoped name; T e = <scoped::value>]
		*/
		constexpr std::string_view from{epeek<T, e>()};
#if defined(__clang__) || defined(__GNUC__)
		if (constexpr auto ep { from.rfind("e = ") }; ep != std::string_view::npos && from[ep + 4] != '(')
		{
			std::string_view result { from.substr(ep + 4) };
			if (auto lc { result.find_first_of(']') }; lc != std::string_view::npos)
				return result.substr(0, lc);
		}
#else
#error "compiler not supported"
#endif
		return {};
	}

	template<typename T>
	requires std::is_enum_v<T>
	static constexpr std::string_view get_type() noexcept
	{
		/*
			static consteval const char* conjure_enum::tpeek() [with T = <type>]
		*/
		constexpr std::string_view from{tpeek<T>()};
#if defined(__clang__) || defined(__GNUC__)
		if (constexpr auto ep { from.rfind("T = ") }; ep != std::string_view::npos)
		{
			std::string_view result { from.substr(ep + 4) };
			if (auto lc { result.find_first_of(']') }; lc != std::string_view::npos)
				return result.substr(0, lc);
		}
#else
#error "compiler not supported"
#endif
		return {};
	}

	template<typename T>
	struct is_scoped : std::integral_constant<bool, requires
	{
		requires std::is_enum_v<T>;
		requires !std::is_convertible_v<T, std::underlying_type_t<T>>;
	}>{};

	template<typename T, T e>
	static constexpr bool is_valid() noexcept
	{
		return !get_name<T, e>().empty();
	}

	template<typename T>
	static constexpr auto values() noexcept
	{
		return values<T>(std::make_index_sequence<enum_max_value - enum_min_value + 1>({}));
	}

	template<typename T>
	static constexpr auto count() noexcept
	{
		return enum_values<T>.size();
	}

	template<typename T, T e>
	static constexpr auto enum_name() noexcept
	{
		constexpr auto result { get_name<T, e>() };
		return fixed_string<result.size()>(result);
	}

	template<typename T>
	static constexpr std::string_view enum_to_string(T value) noexcept
	{
		if (auto result { std::find_if(enum_entries<T>.cbegin(), enum_entries<T>.cend(),
			[value](const auto& pp) { return std::get<T>(pp) == value; }) }; result != enum_entries<T>.cend())
				return std::get<std::string_view>(*result);
		return {};
	}

	template<typename T>
	static constexpr std::optional<T> int_to_enum(int value) noexcept
	{
		if (auto result { std::find_if(enum_entries<T>.cbegin(), enum_entries<T>.cend(),
			[value](const auto& pp) { return std::get<T>(pp) == static_cast<T>(value); }) }; result != enum_entries<T>.cend())
				return std::get<T>(*result);
		return {};
	}

	template<typename T>
	static constexpr std::optional<T> string_to_enum(std::string_view str) noexcept
	{
		if (auto result { std::find_if(enum_entries<T>.cbegin(), enum_entries<T>.cend(),
			[str](const auto& pp) { return std::get<std::string_view>(pp) == str; }) }; result != enum_entries<T>.cend())
				return std::get<T>(*result);
		return {};
	}

	template<typename T>
	static constexpr auto enum_values { values<T>() };

	template<typename T>
	static constexpr auto enum_entries { entries<T>(std::make_index_sequence< enum_values<T>.size()>()) };

	template<typename T>
	static constexpr auto enum_names { names<T>(std::make_index_sequence< enum_values<T>.size()>()) };

	template<typename T, T e>
	static constexpr auto enum_name_v { enum_name<T, e>() };
};

//-----------------------------------------------------------------------------------------
} // FIX8

#endif // FIX8_CONJURE_ENUM_HPP_

