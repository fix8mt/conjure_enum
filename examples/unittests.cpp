//-----------------------------------------------------------------------------------------
// conjure_enum (header only)
// Copyright (C) 2024 Fix8 Market Technologies Pty Ltd
//   by David L. Dight
// see https://github.com/fix8mt/conjure_enum
//
//		Based on magic_enum <https://github.com/Neargye/magic_enum>
//		Licensed under the MIT License <http://opensource.org/licenses/MIT>.
//		SPDX-License-Identifier: MIT
//		Copyright (c) 2019 - 2024 Daniil Goncharov <neargye@gmail.com>.
//
// Lightweight header-only C++20 enum reflection
//
// Distributed under the Boost Software License, Version 1.0 August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//----------------------------------------------------------------------------------------
#include <catch2/catch_test_macros.hpp>
#include <string_view>
#include <fix8/conjure_enum.hpp>

//-----------------------------------------------------------------------------------------
using namespace FIX8;
using namespace std::literals::string_view_literals;

//-----------------------------------------------------------------------------------------
enum class component : int { scheme, authority, userinfo, user, password, host, port, path=12, test=path, query, fragment };
enum component1 : int { scheme, authority, userinfo, user, password, host, port, path=12, query, fragment };

//-----------------------------------------------------------------------------------------
// run as: ctest --output-on-failure
//-----------------------------------------------------------------------------------------
TEST_CASE("is_valid")
{
	REQUIRE(conjure_enum::is_valid<component, component::password>());
	REQUIRE(!conjure_enum::is_valid<component, static_cast<component>(100)>());
	REQUIRE(conjure_enum::is_valid<component1, password>());
	REQUIRE(!conjure_enum::is_valid<component1, static_cast<component1>(100)>());
}

//-----------------------------------------------------------------------------------------
TEST_CASE("is_scoped")
{
	REQUIRE(conjure_enum::is_scoped<component>());
	REQUIRE(!conjure_enum::is_scoped<component1>());
}

//-----------------------------------------------------------------------------------------
TEST_CASE("count")
{
	REQUIRE(conjure_enum::count<component>() == 10);
	REQUIRE(conjure_enum::count<component1>() == 10);
}

//-----------------------------------------------------------------------------------------
TEST_CASE("enum_name")
{
	REQUIRE(conjure_enum::enum_name<component, component::fragment>() == "component::fragment"sv);
	REQUIRE(conjure_enum::enum_name<component1, component1::fragment>() == "fragment"sv);
}

//-----------------------------------------------------------------------------------------
TEST_CASE("enum_names")
{
	static constexpr auto compnames
	{
      std::to_array<std::string_view>
      ({
			"component::scheme", "component::authority", "component::userinfo", "component::user", "component::password",
			"component::host", "component::port", "component::path", "component::query", "component::fragment"
      })
   };
	static constexpr auto compnames1
	{
      std::to_array<std::string_view>
      ({
			"scheme", "authority", "userinfo", "user", "password", "host", "port", "path", "query", "fragment"
      })
   };
	REQUIRE(conjure_enum::enum_names<component> == compnames);
	REQUIRE(conjure_enum::enum_names<component1> == compnames1);
}

//-----------------------------------------------------------------------------------------
TEST_CASE("enum_values")
{
	static constexpr std::array compvalues
	{
		component::scheme, component::authority, component::userinfo, component::user, component::password,
		component::host, component::port, component::path, component::query, component::fragment
	};
	static constexpr std::array compvalues1
	{
		scheme, authority, userinfo, user, password, host, port, path, query, fragment
	};
	REQUIRE(conjure_enum::enum_values<component> == compvalues);
	REQUIRE(conjure_enum::enum_values<component1> == compvalues1);
}

//-----------------------------------------------------------------------------------------
TEST_CASE("enum_entries")
{
	static constexpr auto compentries
	{
      std::to_array<std::tuple<component, std::string_view>>
      ({
			{ component::scheme, "component::scheme" },
			{ component::authority, "component::authority" },
			{ component::userinfo, "component::userinfo" },
			{ component::user, "component::user" },
			{ component::password, "component::password" },
			{ component::host, "component::host" },
			{ component::port, "component::port" },
			{ component::path, "component::path" },
			{ component::query, "component::query" },
			{ component::fragment, "component::fragment" }
      })
   };
	static constexpr auto compentries1
	{
      std::to_array<std::tuple<component1, std::string_view>>
      ({
			{ scheme, "scheme" },
			{ authority, "authority" },
			{ userinfo, "userinfo" },
			{ user, "user" },
			{ password, "password" },
			{ host, "host" },
			{ port, "port" },
			{ path, "path" },
			{ query, "query" },
			{ fragment, "fragment" }
      })
   };
	REQUIRE(conjure_enum::enum_entries<component> == compentries);
	REQUIRE(conjure_enum::enum_entries<component1> == compentries1);
}

//-----------------------------------------------------------------------------------------
TEST_CASE("enum_to_string")
{
	REQUIRE(conjure_enum::enum_to_string(component::path) == "component::path");
	REQUIRE(conjure_enum::enum_to_string(component::test) == "component::path"); // alias
	REQUIRE(conjure_enum::enum_to_string(path) == "path");
}

//-----------------------------------------------------------------------------------------
TEST_CASE("string_to_enum")
{
	REQUIRE(static_cast<int>(conjure_enum::string_to_enum<component>("component::path").value()) == 12);
	REQUIRE(static_cast<int>(conjure_enum::string_to_enum<component1>("path").value()) == 12);
	REQUIRE(static_cast<int>(conjure_enum::string_to_enum<component>("wrong").value_or(component(100))) == 100);
}

//-----------------------------------------------------------------------------------------
TEST_CASE("int_to_enum")
{
	REQUIRE(conjure_enum::int_to_enum<component>(4).value() == component::password);
	REQUIRE(conjure_enum::int_to_enum<component1>(4).value() == password);
	REQUIRE(conjure_enum::int_to_enum<component>(11).value_or(static_cast<component>(100)) == static_cast<component>(100));
	REQUIRE(conjure_enum::int_to_enum<component1>(11).value_or(static_cast<component1>(100)) == static_cast<component1>(100));
}

//-----------------------------------------------------------------------------------------
TEST_CASE("get_name")
{
	REQUIRE(conjure_enum::get_name<component, component::scheme>() == "component::scheme");
	REQUIRE(conjure_enum::get_name<component1, scheme>() == "scheme");
}

//-----------------------------------------------------------------------------------------
TEST_CASE("get_type")
{
	REQUIRE(conjure_enum::get_type<component>() == "component");
	REQUIRE(conjure_enum::get_type<component1>() == "component1");
}

