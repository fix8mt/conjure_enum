//-----------------------------------------------------------------------------------------
// conjure_enum (header only)
// Copyright (C) 2024 Fix8 Market Technologies Pty Ltd
//   by David L. Dight
// see https://github.com/fix8mt/conjure_enum
//
//		Based on magic_enum <https://github.com/Neargye/magic_enum>
//		Licensed under the MIT License <http://opensource.org/licenses/MIT>.
//		SPDX-License-Identifier: MIT
//		Copyright (c) 2019 - 2024 Daniil Goncharov <neargye@gmail.com>.
//
// Lightweight header-only C++20 enum reflection
//
// Distributed under the Boost Software License, Version 1.0 August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//----------------------------------------------------------------------------------------
#include <iostream>
#include <iomanip>

#include <fix8/conjure_enum.hpp>

using namespace std::literals::string_view_literals;
using namespace std::literals::string_literals;
//-----------------------------------------------------------------------------------------
using namespace FIX8;

enum class component : int { scheme, authority, userinfo, user, password, host, port, path=12, test=path, query, fragment };
enum component1 : int { scheme, authority, userinfo, user, password, host, port, path=12, query, fragment };
enum class numbers : int { zero, one, two, three, four, five, six, seven, eight, nine };
enum class numbers1 : int { zero=4, one=3, two=2, three, four, five, six, seven, eight, nine };

int main(int argc, char *argv[])
{
	/*
	std::cout << get_name(epeek<component, component::user>()) << '\n';
	*/
	if (conjure_enum<component>::is_valid<component::password>())
		std::cout << "valid\n";
	else
		std::cout << "not valid\n";
	if (conjure_enum<component>::is_valid<static_cast<component>(16)>())
		std::cout << "valid\n";
	else
		std::cout << "not valid\n";

	/*
	for(const auto ev : conjure_enum::enum_values<component>)
		std::cout << static_cast<int>(ev) << '\n';
	for(const auto [a, b] : conjure_enum::enum_entries<component>)
		std::cout << '*' << static_cast<int>(a) << ' ' << conjure_enum::remove_scope<component>(b) << '\n';
	for(const auto ev : conjure_enum::enum_values<component1>)
		std::cout << static_cast<int>(ev) << '\n';
	for(const auto ev : conjure_enum::enum_names<component>)
		std::cout << ev << '\n';
	std::cout << conjure_enum::enum_names<component>[5] << '\n';
	enum_bitset<numbers> n1(numbers::zero,numbers::one,numbers::three,numbers::seven,numbers::nine);
	n1.for_each([](numbers val) noexcept
	{
		std::cout << conjure_enum::enum_to_string<numbers>(val) << '(' << static_cast<int>(val) << ')' << '\n';
	});
		*/
	/*
	for (auto itr{conjure_enum::cbegin<component>()}; itr != conjure_enum::cend<component>(); ++itr)
	{
		const auto [a, b] {*itr};
		std::cout << static_cast<int>(a) << ' ' << conjure_enum::remove_scope<component>(b) << '\n';
	}*/

	/*
	std::cout << "1: " << std::string_view(conjure_enum::enum_name_v<component, component::fragment>) << '\n';
	std::cout << "2: " << conjure_enum::enum_name<component, component::fragment>().get() << '\n';
	std::cout << "3: " << conjure_enum::enum_to_string(component::path, true) << '\n';
	std::cout << "4: " << conjure_enum::enum_to_string(component::test) << '\n';
	std::cout << "16: " << '\"' << conjure_enum::enum_to_string(static_cast<component>(100)) << '\"' << '\n';
	std::cout << "5: " << conjure_enum::enum_to_string(path) << '\n';
	std::cout << "6: " << static_cast<int>(conjure_enum::string_to_enum<component>("component::path").value()) << '\n';
	std::cout << "7: " << static_cast<int>(conjure_enum::string_to_enum<component1>("path").value()) << '\n';
	std::cout << "8: " << static_cast<int>(conjure_enum::string_to_enum<component>("wrong").value_or(component(100))) << '\n';
	std::cout << "9: " << conjure_enum::get_name<component1, scheme>() << '\n';
	std::cout << "10: " << conjure_enum::get_name<component, component::scheme>() << '\n';
	std::cout << "16: " << conjure_enum::get_type<component>() << '\n';
	std::cout << "16: " << conjure_enum::get_type<component1>() << '\n';
	*/

	/*
	//using enum component;
	//std::cout << std::boolalpha << is_scoped<component, scheme>() << '\n';
	std::cout << "11: " << std::boolalpha << conjure_enum::is_scoped<component>() << '\n';
	std::cout << "12: " << std::boolalpha << conjure_enum::is_scoped<component1>() << '\n';
	std::string_view res1 { conjure_enum::enum_name_v<component, component::userinfo> };
	std::cout << "13: " << res1 << '\n';
	std::cout << "14: " << conjure_enum::enum_name_v<component, component::userinfo> << '\n';
	std::cout << "15: " << conjure_enum::count<component>() << '\n';
	if (auto result {conjure_enum::int_to_enum<component>(100)}; result)
		std::cout << static_cast<int>(*result) << '\n';
	else
		std::cout << "invalid int to enum\n";
	if (auto result {conjure_enum::int_to_enum<component>(12)}; result)
		std::cout << static_cast<int>(*result) << '\n';
	else
		std::cout << "invalid int to enum\n";

	int total{};
	auto myfunc { conjure_enum::for_each<component>([](component val, int other, int& tot)
	{
		std::cout << static_cast<int>(val) << ' ' << other << '\n';
		tot += static_cast<int>(val);
	}, 10, std::ref(total)) };
	myfunc(component::fragment);
	std::cout << total << '\n';

	// enum_bitset
	enum class numbers : int { zero, one, two, three, four, five, six, seven, eight, nine };
	//enum_bitset<component> ec;
	enum_bitset<numbers> eb;
	eb.set_all<numbers::zero,numbers::two,numbers::five,numbers::nine>();
	std::cout << eb << '\n';
	std::cout << eb.test_all<numbers::zero,numbers::two,numbers::five,numbers::nine>() << '\n';
	eb.clear_all<numbers::five>();
	std::cout << eb.test_all<numbers::zero,numbers::two,numbers::five,numbers::nine>() << '\n';
	std::cout << eb << '\n';
	eb.clear(numbers::nine);
	std::cout << eb << '\n';
	enum_bitset<numbers> ec(numbers::one,numbers::three,numbers::six);
	std::cout << ec << '\n';
	std::cout << ec.to_string('-', '+') << '\n'<< '\n';
	std::cout << ec << '\n';
	ec.flip<numbers::one>();
	std::cout << ec << '\n';
	ec.flip<numbers::one>();
	std::cout << ec << '\n';
	ec.flip();
	std::cout << ec << '\n';
	ec.flip();
	std::cout << ec << '\n';
	std::cout << std::boolalpha << conjure_enum<component>::enum_contains("component::path"sv) << '\n';
	std::cout << std::boolalpha << conjure_enum<component>::enum_contains(argv[1]) << '\n';
	for(const auto [a, b] : conjure_enum<component>::enum_entries_sorted)
		std::cout << conjure_enum<component>::remove_scope(b) << ' ' << static_cast<int>(a) << '\n';
	for(const auto [a, b] : conjure_enum<numbers1>::enum_entries)
		std::cout << b << ' ' << static_cast<int>(a) << '\n';
	*/
	std::cout << conjure_enum<component>::add_scope("path"sv) << '\n';
	std::cout << conjure_enum<component>::add_scope("component::path"sv) << '\n';
	std::cout << conjure_enum<component1>::add_scope("path"sv) << '\n';
	std::cout << conjure_enum<component>::epeek<component::path>() << '\n';
	std::cout << conjure_enum<component>::tpeek() << '\n';
	return 0;
}
