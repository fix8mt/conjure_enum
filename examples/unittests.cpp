//-----------------------------------------------------------------------------------------
// conjure_enum (header only)
// Copyright (C) 2024 Fix8 Market Technologies Pty Ltd
//   by David L. Dight
// see https://github.com/fix8mt/conjure_enum
//
//		Based on magic_enum <https://github.com/Neargye/magic_enum>
//		Licensed under the MIT License <http://opensource.org/licenses/MIT>.
//		SPDX-License-Identifier: MIT
//		Copyright (c) 2019 - 2024 Daniil Goncharov <neargye@gmail.com>.
//
// Lightweight header-only C++20 enum reflection
//
// Distributed under the Boost Software License, Version 1.0 August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//----------------------------------------------------------------------------------------
#include <catch2/catch_test_macros.hpp>
#include <string_view>
#include <iostream>
#include <fix8/conjure_enum.hpp>

//-----------------------------------------------------------------------------------------
using namespace FIX8;
using namespace std::literals::string_view_literals;
using namespace std::literals::string_literals;

//-----------------------------------------------------------------------------------------
enum class component : int { scheme, authority, userinfo, user, password, host, port, path=12, test=path, query, fragment };
enum component1 : int { scheme, authority, userinfo, user, password, host, port, path=12, query, fragment };
enum class numbers { zero, one, two, three, four, five, FIVE=five, six, seven, eight, nine };

//-----------------------------------------------------------------------------------------
// run as: ctest --output-on-failure
//-----------------------------------------------------------------------------------------
TEST_CASE("is_valid")
{
	REQUIRE(conjure_enum::is_valid<component, component::password>());
	REQUIRE(!conjure_enum::is_valid<component, static_cast<component>(100)>());
	REQUIRE(conjure_enum::is_valid<component1, password>());
	REQUIRE(!conjure_enum::is_valid<component1, static_cast<component1>(100)>());
}

//-----------------------------------------------------------------------------------------
TEST_CASE("is_scoped")
{
	REQUIRE(conjure_enum::is_scoped<component>());
	REQUIRE(!conjure_enum::is_scoped<component1>());
}

//-----------------------------------------------------------------------------------------
TEST_CASE("count")
{
	REQUIRE(conjure_enum::count<component>() == 10);
	REQUIRE(conjure_enum::count<component1>() == 10);
}

//-----------------------------------------------------------------------------------------
TEST_CASE("enum_name")
{
	REQUIRE(conjure_enum::enum_name<component, component::fragment>() == "component::fragment"sv);
	REQUIRE(conjure_enum::enum_name<component1, component1::fragment>() == "fragment"sv);
}

//-----------------------------------------------------------------------------------------
TEST_CASE("enum_names")
{
	static constexpr auto compnames
	{
      std::to_array<std::string_view>
      ({
			"component::scheme", "component::authority", "component::userinfo", "component::user", "component::password",
			"component::host", "component::port", "component::path", "component::query", "component::fragment"
      })
   };
	static constexpr auto compnames1
	{
      std::to_array<std::string_view>
      ({
			"scheme", "authority", "userinfo", "user", "password", "host", "port", "path", "query", "fragment"
      })
   };
	REQUIRE(conjure_enum::enum_names<component> == compnames);
	REQUIRE(conjure_enum::enum_names<component1> == compnames1);
}

//-----------------------------------------------------------------------------------------
TEST_CASE("enum_values")
{
	static constexpr std::array compvalues
	{
		component::scheme, component::authority, component::userinfo, component::user, component::password,
		component::host, component::port, component::path, component::query, component::fragment
	};
	static constexpr std::array compvalues1
	{
		scheme, authority, userinfo, user, password, host, port, path, query, fragment
	};
	REQUIRE(conjure_enum::enum_values<component> == compvalues);
	REQUIRE(conjure_enum::enum_values<component1> == compvalues1);
}

//-----------------------------------------------------------------------------------------
TEST_CASE("enum_entries")
{
	static constexpr auto compentries
	{
      std::to_array<std::tuple<component, std::string_view>>
      ({
			{ component::scheme, "component::scheme" },
			{ component::authority, "component::authority" },
			{ component::userinfo, "component::userinfo" },
			{ component::user, "component::user" },
			{ component::password, "component::password" },
			{ component::host, "component::host" },
			{ component::port, "component::port" },
			{ component::path, "component::path" },
			{ component::query, "component::query" },
			{ component::fragment, "component::fragment" }
      })
   };
	static constexpr auto compentries1
	{
      std::to_array<std::tuple<component1, std::string_view>>
      ({
			{ scheme, "scheme" },
			{ authority, "authority" },
			{ userinfo, "userinfo" },
			{ user, "user" },
			{ password, "password" },
			{ host, "host" },
			{ port, "port" },
			{ path, "path" },
			{ query, "query" },
			{ fragment, "fragment" }
      })
   };
	REQUIRE(conjure_enum::enum_entries<component> == compentries);
	REQUIRE(conjure_enum::enum_entries<component1> == compentries1);
}

//-----------------------------------------------------------------------------------------
TEST_CASE("enum_contains")
{
	REQUIRE(conjure_enum::enum_contains(component::path));
	REQUIRE(conjure_enum::enum_contains(component::test)); // alias
	REQUIRE(conjure_enum::enum_contains(path));
	REQUIRE(!conjure_enum::enum_contains(static_cast<component>(100)));
	REQUIRE(conjure_enum::enum_contains<component>("component::path"sv));
	REQUIRE(conjure_enum::enum_contains<component1>("path"sv));
}

//-----------------------------------------------------------------------------------------
TEST_CASE("enum_to_string")
{
	REQUIRE(conjure_enum::enum_to_string(component::path) == "component::path");
	REQUIRE(conjure_enum::enum_to_string(component::test) == "component::path"); // alias
	REQUIRE(conjure_enum::enum_to_string(path) == "path");
	REQUIRE(conjure_enum::enum_to_string(static_cast<component>(100)).empty());
}

//-----------------------------------------------------------------------------------------
TEST_CASE("remove_scope")
{
	REQUIRE(conjure_enum::remove_scope<component>(conjure_enum::enum_name<component, component::fragment>()) == "fragment"sv);
	REQUIRE(conjure_enum::remove_scope<component1>(conjure_enum::enum_name<component1, fragment>()) == "fragment"sv);
}

//-----------------------------------------------------------------------------------------
TEST_CASE("iterators")
{
	auto itr{conjure_enum::cbegin<component>()};
	const auto [a, b] {*itr};
	REQUIRE(a == component::scheme);
	REQUIRE(b == "component::scheme"sv);
	int cnt{};
	for (; itr != conjure_enum::cend<component>(); ++itr)
		++cnt;
	REQUIRE(cnt == conjure_enum::count<component>());
}

//-----------------------------------------------------------------------------------------
TEST_CASE("string_to_enum")
{
	REQUIRE(static_cast<int>(conjure_enum::string_to_enum<component>("component::path").value()) == 12);
	REQUIRE(static_cast<int>(conjure_enum::string_to_enum<component1>("path").value()) == 12);
	REQUIRE(static_cast<int>(conjure_enum::string_to_enum<component>("wrong").value_or(component(100))) == 100);
}

//-----------------------------------------------------------------------------------------
TEST_CASE("int_to_enum")
{
	REQUIRE(conjure_enum::int_to_enum<component>(4).value() == component::password);
	REQUIRE(conjure_enum::int_to_enum<component1>(4).value() == password);
	REQUIRE(conjure_enum::int_to_enum<component>(11).value_or(static_cast<component>(100)) == static_cast<component>(100));
	REQUIRE(conjure_enum::int_to_enum<component1>(11).value_or(static_cast<component1>(100)) == static_cast<component1>(100));
}

//-----------------------------------------------------------------------------------------
TEST_CASE("get_name")
{
	REQUIRE(conjure_enum::get_name<component, component::scheme>() == "component::scheme");
	REQUIRE(conjure_enum::get_name<component1, scheme>() == "scheme");
}

//-----------------------------------------------------------------------------------------
TEST_CASE("get_type")
{
	REQUIRE(conjure_enum::get_type<component>() == "component");
	REQUIRE(conjure_enum::get_type<component1>() == "component1");
}

//-----------------------------------------------------------------------------------------
TEST_CASE("for_each")
{
	int total{};
	auto myfunc { conjure_enum::for_each<component>([](component val, int& tot)
	{
		tot += static_cast<int>(val);
	}, std::ref(total)) };
	myfunc(component::fragment);
	REQUIRE(total == 74);
}

//-----------------------------------------------------------------------------------------
TEST_CASE("enum_bitset")
{
	enum_bitset<numbers> eb;
	eb.set_all<numbers::zero,numbers::two,numbers::five,numbers::nine>();
	REQUIRE(eb.test_all<numbers::zero,numbers::two,numbers::five,numbers::nine>());
	eb.clear_all<numbers::FIVE>(); // use alias
	REQUIRE(!eb.test_all<numbers::zero,numbers::two,numbers::five,numbers::nine>());
	eb.clear(numbers::nine);
	REQUIRE(!eb.test(numbers::nine));

	enum_bitset<numbers> ec(numbers::one,numbers::three,numbers::six);
	REQUIRE(ec.to_ulong() == (1 << 1 | 1 << 3 | 1 << 6));
	REQUIRE(ec.to_string() == "0001001010"s);
	REQUIRE(ec.to_ulong() == 0b0001001010);
	REQUIRE(ec.to_string('-', '+') == "---+--+-+-"s);

	REQUIRE(ec.test<numbers::one>());
	ec.flip<numbers::one>();
	REQUIRE(!ec.test<numbers::one>());
	ec.flip<numbers::one>();
	REQUIRE(ec.test<numbers::one>());
	ec.flip();
	REQUIRE(ec.to_ulong() == 0b1110110101);
	REQUIRE(ec.count() == 7);
	ec.clear<numbers::three>();
	REQUIRE(!ec.test<numbers::three>());
	ec.set<numbers::three>();
	REQUIRE(ec.test<numbers::three>());
	ec.clear(numbers::three);
	REQUIRE(!ec.test<numbers::three>());
	ec.set(numbers::three);
	REQUIRE(ec.test<numbers::three>());

	enum_bitset<numbers> ed(numbers::two,numbers::three,numbers::four,numbers::seven);
	REQUIRE(ed.test_all<numbers::two,numbers::three,numbers::four,numbers::seven>());
	REQUIRE(ed.test_any<numbers::two,numbers::three,numbers::four,numbers::seven>());
	REQUIRE((ed << 1) == 0b0100111000);
	ed <<= 1;
	REQUIRE(ed.to_ulong() == 0b0100111000);
	REQUIRE((ed >> 1) == 0b0010011100);
	ed >>= 1;
	REQUIRE(ed.to_ulong() == 0b0010011100);

	REQUIRE((ed | numbers::one) == 0b0010011110);
	REQUIRE((ed & numbers::two) == 0b100);
	ed |= numbers::one;
	REQUIRE(ed.to_ulong() == 0b0010011110);
	ed &= numbers::one;
	REQUIRE(ed.to_ulong() == 0b10);
	//std::cerr << ed << '\n';

	ed.clear();
	REQUIRE(!ed);
	REQUIRE((ed ^ numbers::one) == 0b010);
	ed ^= numbers::one;
	REQUIRE(ed.to_ulong() == 0b010);

	enum_bitset<numbers> ee(0b10101010);
	std::ostringstream ostr;
	ee.for_each([&ostr](numbers val) noexcept
	{
		ostr << conjure_enum::enum_to_string<numbers>(val) << '(' << static_cast<int>(val) << ')' << '\n';
	});
	REQUIRE(ostr.str() ==
R"(numbers::one(1)
numbers::three(3)
numbers::five(5)
numbers::seven(7)
)");
}

